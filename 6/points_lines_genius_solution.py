"""
Ivan Andreev
Всё это дело можно свести к единственной сортировке массива размером m+2nm+2n, получив сложность O((m+n)log(m+n))O((m+n)log(m+n)).
(Кстати, решения с `bisect` дают сложность O(m \log n)O(mlogn).)
Берём числовую прямую и размещаем на ней три вида объектов: начала отрезков, концы отрезков и точки. После чтения stdin вся эта
куча точек (heap) неупорядочена. Отсортируем её по координате xx. Теперь сделаем по ней один единственный проход слева направо.
Сначала предположим для простоты, что никакие две координаты точек, начал и концов отрезков не совпадают. Когда мы встречаем
очередной объект, то смотрим: если это начало отрезка, значит мы немного заглубились в отрезки -- увеличиваем вложенность на 1.
Если это конец отрезка, уменьшаем текущую вложенность отрезков на 1. Если это точка, то выведем текущее значение вложенности для
этой точки.
Если на входе вдруг попадутся невалидные отрезки, у которых левый конец больше правого, то они могут усложнить порядок расчёта
глубины. Просто отбросим их при вводе.
Теперь немного доработаем алгоритм, чтобы он не путался, когда координаты точек и концов отрезков совпадают. Нам надо, чтобы
при их совпадении всегда был такой порядок: левый конец отрезка, точка, правый конец отрезка (а иначе отрезок для точки, лежащей
точно на его конце, не посчитается). Для этого будем класть в массив не просто координату, а кортеж: (координата,тип_объекта),
причём тип левого конца (-1) будет при сравнении меньше типа точки (0) и меньше правого конца (1).
Осталось учесть случай, когда отрезки вкладываются друг в друга, и координаты их концов совпадают: нам надо, чтобы если отрезок А
открылся раньше, то чтобы он позже закрылся. Для этого добавим в кортеж третье число: номер отрезка. Причём для начал отрезков
будем класть номер со знаком "+", чтобы они шли в прямом порядке, а для правых концов -- со знаком "-", чтобы порядок инвертировался.
Для точек третий элемент кортежа тоже пригодится: будем класть туда порядковый номер точки во входном потоке, чтобы вывести
их вложенность в правильном порядке.
Для краткости я привожу решение, в котором использовал стандартную библиотечную сортировку, но у меня получалось использовать
и рукописный `merge_sort` и `quick_sort`. Правда, с `quick_sort` была заковыка: обязательно надо было делить не на 2, а на 3 части.
Кроме того, вариант с выбором поворотной точки по медиане не проходил 4-й тест. Выбор по рандому проходил нормально.

"""


from sys import stdin
read = lambda: map(int, stdin.readline().split())
n_cuts, n_dots = read()
heap = []
for i in range(n_cuts):
    lx, rx = read()
    if lx <= rx:
        heap.append((lx, -1, i))
        heap.append((rx, 1, -i))
for i, dx in enumerate(read()):
    heap.append((dx, 0, i))
assert i+1 == n_dots
hits = [0] * n_dots
heap.sort()
depth = 0
for x, etype, i in heap:
    if etype == 0:
        hits[i] = depth
    elif etype < 0:
        depth += 1
    else:
        depth -= 1
print(*hits)